
import java.nio.file.Path;
import java.nio.file.Paths;
import org.apache.tools.ant.taskdefs.condition.Os

// override the build directory
project.buildDir = '.env'

def sanitize(name) {
  name.toLowerCase().replaceAll("\\W+", "_")
}

def hasDocker() {
  try {
    def process = 'docker'.execute()
    process.waitForOrKill(200000)
    process.exitValue() == 0
  } catch(Exception ex) { false }
}

ext {

  // read the mode project property
  mode = project.hasProperty('mode') ? mode : 'test'
  mode = mode.toLowerCase()

  // read the dockerImage project property
  host = project.hasProperty('dockerImage') ? dockerImage : 'gradle_host'
  hostDir = Paths.get(buildDir.toString(), sanitize(host)).toString()

  cmakeGenerator = project.hasProperty('cmakeGenerator') ? cmakeGenerator : 'Unix Makefiles'
  cmakeGeneratorDir = Paths.get(hostDir, sanitize(cmakeGenerator)).toString()

  cmakeToolchainFile = project.hasProperty('cmakeToolchainFile') ? cmakeToolchainFile : 'default'
  cmakeToolchainId = (cmakeToolchainFile == 'default') ? 'default' : cmakeToolchainFile.digest('SHA-256').take(10)
  cmakeToolchainDir = Paths.get(cmakeGeneratorDir, sanitize(cmakeToolchainId)).toString()

  target = project.hasProperty('target') ? target : host
  targetDir = Paths.get(cmakeToolchainDir, sanitize(target)).toString()

  cmakeBuildType = (mode == 'release') ? 'Release' : 'Debug'
  cmakeBinaryDir = Paths.get(targetDir, sanitize(cmakeBuildType))
  cmakeBinaryDirRelative = projectDir.toPath().relativize(cmakeBinaryDir)
  cmakeBinaryDir = cmakeBinaryDir.toString()

  cmakeBuildTesting = (mode == 'test') ? 'ON' : 'OFF'
  cmakeOptions = project.hasProperty('otherCmakeOptions') ? cmakeOptions : ''

  // capture the number of processors available to the jvm
  availableProcessors = Runtime.getRuntime().availableProcessors();

  isWindows = Os.isFamily(Os.FAMILY_WINDOWS)
  useDocker = hasDocker() && !isWindows && (host != 'gradle_host')

}

def defineTasks() {
  def buildDeps = []
  def cleanDeps = []

  def commandPrefix = isWindows ? ['cmd', '/c'] : []

  task createCmakeBinaryDir { doLast { mkdir cmakeBinaryDir } }
  buildDeps = buildDeps << createCmakeBinaryDir

  if(useDocker) {
    def dockerFile = Paths.get(hostDir, 'Dockerfile')
    def dockerEntrypoint = Paths.get(hostDir, 'entrypoint.sh')
    def imageCreatedFlag = Paths.get(hostDir, 'docker_image_created.flag')
    def dockerImageName = "${buildDir.toString().digest('SHA-256').take(10)}_${hostDir.digest('SHA-256').take(10)}"

    task createDockerEntrypoint {
      dependsOn createCmakeBinaryDir
      onlyIf { !file(dockerEntrypoint).exists() }
      doLast {
        file(dockerEntrypoint).write '''\
          #!/bin/bash

          USER_ID=${LOCAL_USER_ID:-9001}

          useradd --shell /bin/bash -u $USER_ID -o -c "" -m builder
          export HOME=/home/builder

          exec gosu builder "$@"'''.stripIndent()
      }
    }

    task createDockerFile {
      def content = ''

      if(host.startsWith('dockcross')) {
        dependsOn createDockerEntrypoint
        content = """\
          FROM ${host}
          COPY entrypoint.sh /usr/local/bin/docker-entrypoint.sh
          RUN chmod +x /usr/local/bin/docker-entrypoint.sh
          WORKDIR /work
          ENTRYPOINT ["/usr/local/bin/docker-entrypoint.sh"]""".stripIndent()
      } else {
        dependsOn createCmakeBinaryDir
        content = """\
          FROM ${host}
          WORKDIR /work
        """.stripIndent()
      }

      onlyIf { !file(dockerFile).exists() }
      doLast {
        file(dockerFile).write content
      }
    }

    task buildDockerImage {
      def command = []
      command.addAll(commandPrefix)
      command.addAll(['docker', 'build', '-t', dockerImageName, '.'])

      dependsOn createDockerFile
      onlyIf { !file(imageCreatedFlag).exists() }
      doLast {
        exec {
          workingDir hostDir
          commandLine command
        }
        file(imageCreatedFlag).write dockerImageName
      }
    }


    def uid = ["id", "-u"].execute().text.trim()
    commandPrefix.addAll([
      'docker', 'run',
      '-e', "LOCAL_USER_ID=${uid}",
      '--workdir', '/work/implementations/c', // this is brittle
      '--rm',
      '--volume', "${projectDir}/../..:/work",
      dockerImageName
    ])

    buildDeps = buildDeps << buildDockerImage

    task run {
      def command = []
      command.addAll(commandPrefix)
      command.addAll(2, ['-it'])
      command.addAll(['sh'])

      dependsOn buildDeps
      doLast {
        println command.join(' ')
      }
    }
  }

  task generate {
    def cmakeCache = Paths.get(cmakeBinaryDir.toString(), 'CMakeCache.txt')
    def command = []

    command.addAll(commandPrefix)
    command.addAll([
      'cmake',
      '--parallel', availableProcessors,
      '-S', '.',
      '-B', cmakeBinaryDirRelative,
      "-DBUILD_TESTING=${cmakeBuildTesting}",
      "-DCMAKE_BUILD_TYPE=${cmakeBuildType}",
      '-DCMAKE_EXPORT_COMPILE_COMMANDS=ON',
      '-G', cmakeGenerator,
      cmakeOptions
    ])

    dependsOn buildDeps
    onlyIf { !file(cmakeCache).exists() }
    doLast {
      exec {
        commandLine command
      }
    }
  }

  task build {
    description 'Build the project.'
    group project.name

    def command = []
    command.addAll(commandPrefix)
    command.addAll(['cmake', '--build', cmakeBinaryDirRelative])
    if(cmakeGenerator == 'Unix Makefiles') {
      command.addAll(['--', "-j${availableProcessors}"])
    }

    dependsOn generate
    doLast {
      exec {
        commandLine command
      }
    }
  }

  task test {
    description 'Test the project.'
    group project.name

    def command = []
    command.addAll(commandPrefix)
    command.addAll(['sh', '-c', "cd ${cmakeBinaryDirRelative} && ctest --verbose"])

    doLast {
      exec {
        commandLine command
      }
    }
  }

  task clean {
    doLast {
      delete buildDir
    }
  }
}

defineTasks()
